/*
 * =====================================================================================
 *
 *       Filename:  overload.cpp
 *
 *    Description:  overload all glibc socket methodes
 *
 *        Version:  1.0
 *        Created:  Friday 17 April 2015 11:51:41  IST
 *       Revision:  none
 *       Compiler:  gcc
 *
 *         Author:  Suman Roy (), 
 *   Organization:  Cognizant Technological solutions
 *
 * =====================================================================================
 */

#include<iostream>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/queue.h>
#include <sys/uio.h>
#include <sys/un.h>
#include <sys/time.h>
#include <mutex>
#include <thread>
#include <netinet/in.h>
#include <err.h>
#include <dlfcn.h>
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <errno.h>
#include <poll.h>
#include <limits.h>
#include <math.h>
#include <pwd.h>
#include <stdarg.h>
#include <string.h>
#include<stdbool.h>
#include <map>
#include "objectpool.hpp"
#define HOME 1
#define __FUNCTION_DECLARE_(funcName, returnType, arguments)\
       	static returnType (*libc_##funcName) arguments


#define __LOAD__ADDR__( var ) do {\
	*(void **) (&libc_##var) = dlsym ( __handle__ , #var); \
	if ( ( __error__ = dlerror ( ) ) != NULL ){\
		std::cerr<<__error__<<std::endl;\
		exit ( -1 );	}	\
} while (0)

ObjectPool                 *__pool__;
char                       *__error__;
void                       *__handle__;
bool                       __isDelay__;
pthread_mutex_t            __objPool__;
pthread_mutex_t            __readLock__;
pthread_mutex_t            __portStat__;
pthread_mutex_t            __writeLock__;
std::map < int , bool >    __registeredSock__;
bool                       __pass__ = false;


bool 
isPresent ( int sockFd ){
	std::map <int , bool >::iterator    it;
	bool                                returnVal;

	it = __registeredSock__.find ( sockFd );
	if ( it != __registeredSock__.end() ) returnVal = true;
	else returnVal = false;

	return returnVal;
}

bool 
registerSock( int sockFd ){
#ifdef DEBUG
	std::cout<<"Register [ "<<sockFd<<" ] \n";
#endif
	std::map <int , bool >::iterator    it;
	bool                                returnVal; 

	it = __registeredSock__.find ( sockFd );
	if ( it == __registeredSock__.end () ){
		__registeredSock__.insert ( std::pair < int , bool >(sockFd , true ) );
		returnVal = true;
	}else returnVal = false;

	return returnVal;
}

__FUNCTION_DECLARE_(dup, int, (int));
__FUNCTION_DECLARE_(close, int, (int));
__FUNCTION_DECLARE_(dup2, int, (int, int));
__FUNCTION_DECLARE_(socket, int, (int, int, int));
__FUNCTION_DECLARE_(dup3, int, (int, int , int ));
__FUNCTION_DECLARE_(read, ssize_t, (int, void *, size_t));
__FUNCTION_DECLARE_(poll, int, (struct pollfd *, int, int));
__FUNCTION_DECLARE_(recv, ssize_t, (int, void *, size_t, int));
__FUNCTION_DECLARE_(write, ssize_t, (int,const void *, size_t));
__FUNCTION_DECLARE_(send, ssize_t, (int, const void *, size_t, int));
__FUNCTION_DECLARE_(readv, ssize_t, (int, const struct iovec *, int));
__FUNCTION_DECLARE_(writev, ssize_t, (int, const struct iovec *, int));
__FUNCTION_DECLARE_(accept, int, (int, struct sockaddr *, socklen_t *));
__FUNCTION_DECLARE_ ( bind , int ,(int , const struct sockaddr* , socklen_t ) );
__FUNCTION_DECLARE_(select, int, (int, fd_set *, fd_set *, fd_set *, struct timeval *));
__FUNCTION_DECLARE_(sendto, ssize_t, (int, const void *, size_t, int,
	    const struct sockaddr *, socklen_t));
__FUNCTION_DECLARE_(recvfrom, ssize_t, (int, void *, size_t, int, struct sockaddr *,
	    socklen_t *));


/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  initOverLoad
 *  Description:  make the environemnt ready........
 * =====================================================================================
 */
void 
initOverLoad(){
	__isDelay__ = true;

	try{
		__pool__ = ObjectPool::getInstance();
		__resilience__::Interface *init;
		init = __pool__->getInterfaceObj( );
		init->init();
		__pool__->returnInterfaceObj( init );
	}
	catch ( const std::bad_alloc &ba ){
		std::cerr<<"\nException on creating instance\
		       	of Interface Handler\nNo delay can maintain";
		__isDelay__ = false;
	}
#ifdef HOME
//to do -- either code will search the libc lib path or have to provide through setenv.
	if ( ( __handle__ = dlopen("/lib/x86_64-linux-gnu/libc.so.6",
					RTLD_LAZY ) ) == NULL ){
		std::cerr<<"Failed to open libc\n";
		exit ( 1 );
		
	}
#else
	if ( ( __handle__ = dlopen("/lib/libc.so.6",RTLD_LAZY ) ) == NULL ){
		std::cerr<<"Failed to open libc\n";
		exit( 1 );
	}

#endif
	  
	__LOAD__ADDR__ ( socket );
	__LOAD__ADDR__( close );
	__LOAD__ADDR__ ( read );
	__LOAD__ADDR__ ( recv );
	__LOAD__ADDR__ ( readv);
	__LOAD__ADDR__ ( recvfrom );
	__LOAD__ADDR__ ( write );
	__LOAD__ADDR__ ( send );
	__LOAD__ADDR__ ( writev );
	__LOAD__ADDR__ ( sendto );
	__LOAD__ADDR__ ( select );
	__LOAD__ADDR__ ( poll );
	__LOAD__ADDR__ ( accept );
	__LOAD__ADDR__ ( dup );
	__LOAD__ADDR__( dup2 );
	__LOAD__ADDR__( dup3 );
	__LOAD__ADDR__ ( bind );

	__pass__ = true;


}


/*-----------------------------------------------------------------------------
 *  
 *   read/recv/ recvfrom :read requested  data from kernel socket buff
 *                 Resilience  Logic: Read the available data from kernel
 *                 buffer. Then if the read Byte( kernel buff) is <= allowed
 *                 byte limit then frwrd is back else send it to the buffer 
 *                 mapped with the FD. and slowly forward to the calling method.
 *                 Buffer cache read returns -1? there is an __error__ on reading
 *                 from the buffer.
 *             
 *-----------------------------------------------------------------------------*/
ssize_t    
preOpRead( int fd , void *buff  , ssize_t & howManyByteCanRead , 
		__resilience__::Interface *&intObj){

	ssize_t    readCount;
#ifdef DEBUG
	std::cout<<"Socket fd:["<<fd<<std::endl;
#endif

	pthread_mutex_lock ( &__objPool__);
	intObj = __pool__->getInterfaceObj();
	pthread_mutex_unlock( &__objPool__);

	pthread_mutex_lock(&__portStat__);
	howManyByteCanRead = intObj->getPortStatus( intObj-> getDestPort( fd) , true );
	pthread_mutex_unlock(&__portStat__);
#ifdef DEBUG
	std::cout<<PRINT<<"Bytes can read["<<howManyByteCanRead<<"]\n";
#endif
	if ( howManyByteCanRead > 0 )
 	readCount = intObj->accessReadBufferData
		( fd , buff , howManyByteCanRead ,  true ); // read data from buffer storago
	else readCount = howManyByteCanRead;
#ifdef DEBUG
	std::cout<<PRINT<<" Bytes read from Read\
	       	Buff [ "<<readCount<<" ] \n";
#endif
	return readCount ;
	
} 

ssize_t 
preOpSend ( int fd , void *buff , size_t len , bool &fstTime   ) {
#ifdef DEBUG
	std::cout<<PRINT<<" Fd [ "<<fd<< " ] Size [ "
		<< len<< "] fstTime [ "<<fstTime <<" ]"<<std::endl;
#endif
	ssize_t    sendCount;
	ssize_t    bytesCanHandleWindow;

	__resilience__::Interface    *intObj;
	pthread_mutex_lock ( &__objPool__);
	intObj = __pool__->getInterfaceObj();
	pthread_mutex_unlock( &__objPool__);
	pthread_mutex_lock(&__portStat__);
       
	bytesCanHandleWindow = 
		intObj->getPortStatus( intObj->getDestPort( fd ) , false );
	pthread_mutex_unlock(&__portStat__);
#ifdef DEBUG
	std::cout<<PRINT<<"Bytes can write this \
		windo time [ "<<bytesCanHandleWindow<<" ] \n";
#endif
	//extra bytes need to update in the send buffer
	if ( !fstTime && bytesCanHandleWindow > 0){
		sendCount =intObj->accessSendBufferData( fd , buff , 
				bytesCanHandleWindow , true );
		intObj->updateByteCountCurrentWindow(
			      	intObj->getDestPort( fd) , sendCount  , false );
	}
	else if( bytesCanHandleWindow > 0 ){
		sendCount =  intObj->updateSendBuffer( 
				len , bytesCanHandleWindow , fd , buff );
		fstTime = false;
	} else sendCount =0;// bytesCanHandleWindow;
	pthread_mutex_lock( &__objPool__ );
	__pool__->returnInterfaceObj( intObj );
	pthread_mutex_unlock( &__objPool__);

	return sendCount;

}
/*-----------------------------------------------------------------------------
 *  all the below methodes are a wrapper for libc sock methodes..
 *  to understand the method description plese do "man methodName"
 *-----------------------------------------------------------------------------*/
int 
socket( int sockDomain , int sockType , int sockProtocol ){
#ifdef DEBUG
	std::cout<<PRINT<<std::endl;
#endif	
	int    sock;

	if ( !__pass__  ) initOverLoad();
	sock = ( *libc_socket ) ( sockDomain, sockType , sockProtocol );
#ifdef DEBUG
	std::cout<<"\n Socket created:"<<sock<<std::endl;
#endif
	return ( sock );
}

int 
close ( int fd ){   // to do--- remove the entry of the closed from all DS

	int    cls;
	cls = (*libc_close)(fd);
	return cls;
}
 
 
ssize_t 
read( int fd , void *buff , size_t noBytes ){

	if ( (ssize_t )noBytes == 0 || !isPresent( fd ) ) 
		return ( (*libc_read)(fd , buff , noBytes ) );

	bool                         pass;
	__resilience__::Interface    *intObj;
	ssize_t                      readCount;
	ssize_t                      howManyByteCanRead;

	
#ifdef DEBUG
	std::cout<<"Socket fd:["<<fd<<std::endl;
#endif
	if ( __isDelay__ ){
	pthread_mutex_lock(&__readLock__);
	pass = true;
		readCount = preOpRead( fd , buff, 
				howManyByteCanRead , intObj   );
		if ( readCount <= 0 && pass ){//it was <=
			readCount = (*libc_read)(fd , buff , noBytes );
			pass = false;
#ifdef DEBUG
			std::cout<<PRINT<<"Read from kernel net\
			       	buffer [ " << readCount<<" ] \n";
#endif
		}
		readCount = intObj->updateReadBuffer(  
				howManyByteCanRead , readCount ,fd  , buff );
#ifdef DEBUG
		std::cout<<PRINT<<" Sending Read data [ \
			"<<readCount<<"]"<<std::endl;
#endif
		pthread_mutex_unlock(&__readLock__);
		pthread_mutex_lock( &__objPool__ );
		__pool__->returnInterfaceObj( intObj );
		pthread_mutex_unlock( &__objPool__);
	}else readCount = (*libc_read)(fd , buff , noBytes );

	return readCount;
}


ssize_t 
recv( int fd , void* buff , size_t len, int flags ){
	if ( (ssize_t)len ==0 || !isPresent( fd ) ) 
		return ( (*libc_recv)(fd , buff , len , flags ));
	
	if ( !__pass__ ) initOverLoad();

	__resilience__::Interface    *intObj;
	ssize_t                      readCount;
	ssize_t                      howManyByteCanRead;
#ifdef DEBUG
	std::cout<<"Socket fd:["<<fd<<std::endl;
#endif
	if ( __isDelay__ ){
		pthread_mutex_lock(&__readLock__);
		readCount = preOpRead( fd , buff, howManyByteCanRead  , intObj );
		if ( readCount <= 0 ){
			readCount  = (*libc_recv)(fd , buff , len , flags );
#ifdef DEBUG
			std::cout<<PRINT<<"Read from kernel net \
				buffer [ " << readCount<<" ] \n";
#endif
		}
		readCount = intObj->updateReadBuffer(  
				howManyByteCanRead , readCount ,fd  , buff );
		pthread_mutex_unlock(&__readLock__);
		pthread_mutex_lock( &__objPool__ );
		__pool__->returnInterfaceObj( intObj );
		pthread_mutex_unlock( &__objPool__);

	}else readCount  = (*libc_recv)(fd , buff , len , flags );

	return readCount;

}


ssize_t 
readv( int __fd__ , const struct iovec* __iovec__ , int __iovCount__){
	if ( !__pass__ ) initOverLoad();
	ssize_t    readCount;

	readCount = (*libc_readv )(__fd__ , __iovec__ , __iovCount__ );
	return readCount;
}

ssize_t 
recvfrom ( int fd, void* buff , size_t len , int flags , struct sockaddr * from , 
		socklen_t *fromlen ){
	if ( (ssize_t)len == 0 || !isPresent( fd )) 
		return ( (*libc_recvfrom )( fd , buff , len , flags , from , fromlen ) );
	if ( !__pass__ ) initOverLoad();
	ssize_t                      readCount;
	ssize_t                      howManyByteCanRead;
	__resilience__::Interface    *intObj;
#ifdef DEBUG
	std::cout<<"Socket fd:["<<fd<<std::endl;
#endif
	if ( __isDelay__ ){
		pthread_mutex_lock(&__readLock__);
		readCount = preOpRead( fd , buff, howManyByteCanRead , intObj );
		if ( readCount <= 0 ){
			readCount = (*libc_recvfrom )( fd , buff , len , 
					flags , from , fromlen );
		}
		readCount = intObj->updateReadBuffer(  howManyByteCanRead , 
				readCount ,fd  , buff );
		pthread_mutex_unlock(&__readLock__);
	pthread_mutex_lock( &__objPool__ );
	__pool__->returnInterfaceObj( intObj );
	pthread_mutex_unlock( &__objPool__);
	}else readCount  = (*libc_recvfrom )( fd , buff , len , flags , 
			from , fromlen );

	return readCount;
}

ssize_t 
write(int fd ,const void * buff, size_t len ){
	if ( len == 0 || !isPresent( fd ) ) 
		return ((*libc_write)(fd  , buff , len ) );
#ifdef DEBUG
	std::cout<<PRINT<<" FD [ "<<fd<<" ] Pass [ "<<__pass__ <<" ] IsDelay [ "
		<<__isDelay__  <<" ] Length [ "<<len<<" ] "<<std::endl;
#endif
	if ( !__pass__ ) initOverLoad();

	bool       fstTime;
	ssize_t    byteSend;
	ssize_t    sendCount;
	ssize_t    noOfBytes; 

	noOfBytes = 1;

	if ( __isDelay__ ){
		pthread_mutex_lock(&__writeLock__);
		byteSend = 0;
		fstTime = true;
		char tempBuff [ len +1 ];
		memcpy ( tempBuff , buff , len );
		while ( noOfBytes  > 0 ){
			sendCount = preOpSend ( fd , tempBuff, len , fstTime );
			if ( sendCount > 0 ){
				noOfBytes = (*libc_write)(fd  , tempBuff , sendCount );
				byteSend +=noOfBytes;
#ifdef OUTPUT
				std::cout<<"Byte SENDED to KERNEL\
				       	BUFFER : [ "<<noOfBytes<<" ] \n";
#endif			
			}else noOfBytes = 0;
			if ( byteSend > ( ssize_t ) len ) { std::cout<<"THIS\
			       	SITUATION SHOULD NOT  ";noOfBytes = 0;}
		}
		pthread_mutex_unlock(&__writeLock__ );
		
	} else byteSend  = (*libc_write)(fd  , buff , len  );
#ifdef OUTPUT
	std::cout<<"TOTAL BYTE FORWARDED TO KERNEL BUFFER [ "<<byteSend<<" ] \n";
#endif

	return byteSend ;
}


ssize_t 
send(int fd , const void * buff , size_t len , int  flags ){
	if ( len == 0|| !isPresent( fd ) ) 
		return (  (*libc_send)( fd  , buff , len , flags ) );
	

	if ( !__pass__ ) initOverLoad();

	bool       fstTime;
	ssize_t    byteSend;
	ssize_t    sendCount;
	ssize_t    noOfBytes;

	noOfBytes = 1;

	byteSend = 0;
	fstTime = true;
	if ( __isDelay__ ){
		pthread_mutex_lock(&__writeLock__);
			char tempBuff [ len ];
			memcpy ( tempBuff , buff , len );
		while ( noOfBytes  > 0 ){
			sendCount = preOpSend ( fd , tempBuff, len , fstTime );
			 if ( sendCount > 0 ){
				 noOfBytes = (*libc_send)( fd  , 
						 tempBuff , sendCount , flags );
				 byteSend +=noOfBytes;
			 } else noOfBytes = 0;
			 if ( byteSend >= (ssize_t )len ) noOfBytes = 0;
		}
		pthread_mutex_unlock(&__writeLock__ );
	} else byteSend =  (*libc_send)( fd  , buff , len , flags );

	return byteSend ;
}

ssize_t 
writev(int fd , const struct iovec * iovec , int iovCount ){
	if ( !__pass__ ) initOverLoad();
	ssize_t    noOfBytes;
	noOfBytes = (*libc_writev )( fd , iovec , iovCount );
	return noOfBytes;
}

ssize_t 
sendto(int fd ,  const  void *buff, size_t len, int flags,
		const struct sockaddr *dest_addr, socklen_t addrlen ){
	if ( len == 0|| !isPresent( fd ) ) 
		return (  (*libc_sendto)(fd , buff , len  , flags, dest_addr , addrlen ) );
	if ( !__pass__ ) initOverLoad();

	bool       fstTime;
	ssize_t    byteSend;
	ssize_t    sendCount;
	ssize_t    noOfBytes;

	noOfBytes = 1;
	byteSend = 0;
	fstTime = true;

	if ( __isDelay__ ){
		pthread_mutex_lock(&__writeLock__);
			char tempBuff [ len ];
			memcpy ( tempBuff , buff , len );
		while ( noOfBytes  > 0 ){
			sendCount = preOpSend ( fd , tempBuff, len , fstTime );
			if ( sendCount > 0 ){
				noOfBytes = (*libc_sendto)(fd , tempBuff , 
						sendCount  , flags, dest_addr , addrlen );
				byteSend +=noOfBytes;
			}else noOfBytes = 0;
		}
		pthread_mutex_unlock(&__writeLock__ );

	} else byteSend =  (*libc_sendto)(fd , buff , len  , flags, dest_addr , addrlen );

	return byteSend ;

}

int 
select(int nfds , fd_set * read_fds, fd_set * write_fds, fd_set *exceptfds, 
		struct timeval * timeout){

	if ( !__pass__ ) initOverLoad();

	int   noFd;
	noFd = (*libc_select)( nfds , read_fds , write_fds , exceptfds , timeout );

	return noFd;
}

int 
poll(struct pollfd *fds, nfds_t nfds, int timeout){

	if ( !__pass__ ) initOverLoad();

	int    returnVal;

	returnVal = (*libc_poll )( fds , nfds , timeout );
	
	return ( returnVal );
}


int 
accept(int fd, struct sockaddr *addr, socklen_t *addrlen){
	if ( !__pass__ ) initOverLoad();

	int    returnVal;

	returnVal = (*libc_accept )( fd , addr , addrlen );
#ifdef DEBUG
	std::cout<<PRINT<<"Update Old FD [ "<<fd <<" ] to New\
	       	Fd [ "<<returnVal<<" ] "<<std::endl;
#endif
	if ( __isDelay__ ){
		__resilience__::Interface    *intObj;
		pthread_mutex_lock ( &__objPool__);
		intObj = __pool__->getInterfaceObj();
		pthread_mutex_unlock( &__objPool__);
		intObj->updateAcceptFd( fd , returnVal ); // update the accepted fd
		registerSock( returnVal );
		pthread_mutex_lock( &__objPool__ );
		__pool__->returnInterfaceObj( intObj );
		pthread_mutex_unlock( &__objPool__);
	}
	return returnVal;

}

int 
dup(int oldfd){
	if ( !__pass__ ) initOverLoad();

	int returnVal;

	returnVal = (*libc_dup )( oldfd );
	if ( returnVal != -1 && __isDelay__  ){

		__resilience__::Interface    *intObj;
		pthread_mutex_lock ( &__objPool__);
		intObj = __pool__->getInterfaceObj();
		pthread_mutex_unlock( &__objPool__);
		intObj->updateAcceptFd( oldfd  , returnVal ); // update the accepted fd
		pthread_mutex_lock( &__objPool__ );
		__pool__->returnInterfaceObj( intObj );
		pthread_mutex_unlock( &__objPool__);
	}

	return returnVal;
 }

int 
dup2(int oldfd, int newfd){
	if ( !__pass__ ) initOverLoad();

	int    returnVal;

	returnVal = (*libc_dup2 )( oldfd , newfd );
	if ( returnVal != -1 && __isDelay__ ){
		__resilience__::Interface    *intObj;
		pthread_mutex_lock ( &__objPool__);
		intObj = __pool__->getInterfaceObj();
		pthread_mutex_unlock( &__objPool__);
		intObj->updateAcceptFd( oldfd  , returnVal ); // update the accepted fd
		pthread_mutex_lock( &__objPool__ );
		__pool__->returnInterfaceObj( intObj );
		pthread_mutex_unlock( &__objPool__);
	}


	return returnVal;
}

int 
dup3(int oldfd, int newfd, int flags){
	if ( !__pass__ ) initOverLoad();

	int    returnVal;

	returnVal = (*libc_dup3 )( oldfd , newfd , flags);
	if ( returnVal != -1 && __isDelay__ ){
		
		__resilience__::Interface    *intObj;
		pthread_mutex_lock ( &__objPool__);
		intObj = __pool__->getInterfaceObj();
		pthread_mutex_unlock( &__objPool__);
		intObj->updateAcceptFd( oldfd  , returnVal ); // update the accepted fd
		pthread_mutex_lock( &__objPool__ );
		__pool__->returnInterfaceObj( intObj );
		pthread_mutex_unlock( &__objPool__);
	}

	return returnVal;
}

int 
bind(int fd, const struct sockaddr *addr, socklen_t addrlen){
#ifdef DEBUG
	std::cout<<PRINT<<"File Descriptor [ "<<fd<<" ] \n";
#endif
	int                          port;
	int                          ipAddr;
	__resilience__::Interface    *intObj;
	int                          returnVal;
	char                         str[INET_ADDRSTRLEN];

	if ( !__pass__ ) initOverLoad();
 
	if ( __pass__ &&  __isDelay__ ){ // environment is ready for delay
		if (addr->sa_family == AF_INET){
		       port = ntohs (((struct sockaddr_in*)addr)->sin_port);
		       ipAddr = ((struct sockaddr_in*)&addr)->sin_addr.s_addr;
		       inet_ntop( AF_INET, &ipAddr, str, INET_ADDRSTRLEN );
		       std::string ip = std::string(str);
		}
		else
			port = ntohs(((struct sockaddr_in6*)addr)->sin6_port);
#ifdef DEBUG
		std::cout<<PRINT<<"FD ["<<fd<<"] port ["<<port<<"]\n";
#endif
		pthread_mutex_lock ( &__objPool__);
		intObj = __pool__->getInterfaceObj();
		pthread_mutex_unlock( &__objPool__);

		if ( !intObj->init( fd , port ) ){
			std::cerr<<PRINT<<" sock FD ["<<fd
				<<"] -- not able to register\n";
			returnVal = -1;
		}
		pthread_mutex_lock( &__objPool__ );
		__pool__->returnInterfaceObj( intObj );
		pthread_mutex_unlock( &__objPool__);

	}returnVal == -1 ? returnVal = -1: 
	returnVal = ( *libc_bind ) ( fd , addr , addrlen );

	return returnVal;

}
/*   
int main(){
	initOverLoad();


	return 0;

}
*/
