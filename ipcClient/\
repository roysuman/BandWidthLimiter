
/****************** CLIENT CODE ****************/
#include "client.hpp"

bool
IpcClient::createClient(){

	bool         returnVal;
	socklen_t    addr_size;
	/*---- Create the socket. The three arguments are: ----*/
	/* 1) Internet domain 2) Stream socket 3) Default protocol (TCP in this case) */
	fd = socket(PF_INET, SOCK_STREAM, 0);
	/*---- Configure settings of the server address struct ----*/
	/* Address family = Internet */
	serverAddr.sin_family = AF_INET;
	/* Set port number, using htons function to use proper byte order */
	serverAddr.sin_port = htons(7891);
	/* Set IP address to localhost */
	serverAddr.sin_addr.s_addr = inet_addr("127.0.0.1");
	/* Set all bits of the padding field to 0 */
	memset(serverAddr.sin_zero, '\0', sizeof serverAddr.sin_zero);  
	/*---- Connect the socket to the server using the address struct ----*/
	addr_size = sizeof serverAddr;
	connect( fd , (struct sockaddr *) &serverAddr, addr_size) == 0 ? returnVal = true:returnVal = false;
	return returnVal;

}

bool
IpcClient::sendData(__updateLimits__  limit ){
	ssize_t   length;
	bool      returnVal;
	char      buffer[ 1000 ];

	send( fd , &limit,sizeof(__updateLimits__ ) , 0 ) == -1? returnVal= false: returnVal= true;
	if ( returnVal ){
		/*---- Read the message from the server into the buffer ----*/
		length =recv(fd, buffer, 1024, 0);
		std::cout<<buffer<<std::endl;
		memset( buffer , '\0' , length );
	}
	return returnVal;

}
void 
IpcClient::usage(void  ){
	std::cout<<"\n\t-u Uplimits\n"
		<<"\t-d Downlimits\n"
		<<"\t-h Help\n"
		<<"\t-l Licence\n"
		<<"\t-i Ipaddress\n"
		<<"\t-p Ports\n"
		<<"\t-v Version"<<std::endl;
	exit(1);
}

int main( int argc , char** argv){
	
	int opt;
	int port;
	int upLimit;
	int downLimit;
	__updateLimits__    limits;
	IpcClient    ipc;
	if ( !ipc.createClient( ) ){
		std::cerr<<"Can't connect with the server\n";
		exit(1);
	}
	upLimit = 0;
	downLimit = 0;
	port = 0;
	while (  ( opt = getopt ( argc , argv ,"lhvi:u:d:l:p:") ) != -1 )
		switch ( opt ){
			case 'u':
				upLimit = atoi( optarg );
				break;
			case 'd':
				downLimit = atoi( optarg );
				break;
			case 'l':
				std::cout<<"\n Licensed under CTS open-source\n";
				break;
			case 'p':
				port = atoi(optarg );
				break;
			case 'v':
				std::cout<<"Version alpha 0.1-- under test\n";
				break;
			case '?':
				if (optopt == 'c')
					std::cerr<<"Option -"<<optopt<<" requires an argument.\n";
				else if (isprint (optopt))
					std::cerr<<"Unknown option "<< optopt<<std::endl;
				ipc.usage();
				break;
			case 'h':
			default:
				ipc.usage();
		}
		argc -= optind  ;
		argv +=optind  ;
		limits.bindPort = port;
		limits.upLimit = upLimit;
		limits.downLimit = downLimit;
		ipc.sendData( limits );
		return 0;
}
